import { Directive, ElementRef, EventEmitter, Injectable, Input, NgModule, NgZone, Output } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/fromEvent';
import 'rxjs/add/observable/timer';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/debounce';
import 'rxjs/add/operator/throttle';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/mergeMap';
var AxisResolverFactory = (function () {
    function AxisResolverFactory() {
    }
    /**
     * @param {?=} vertical
     * @return {?}
     */
    AxisResolverFactory.prototype.create = function (vertical) {
        if (vertical === void 0) { vertical = true; }
        return new AxisResolver(vertical);
    };
    return AxisResolverFactory;
}());
AxisResolverFactory.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
AxisResolverFactory.ctorParameters = function () { return []; };
var AxisResolver = (function () {
    /**
     * @param {?=} vertical
     */
    function AxisResolver(vertical) {
        if (vertical === void 0) { vertical = true; }
        this.vertical = vertical;
    }
    /**
     * @return {?}
     */
    AxisResolver.prototype.clientHeightKey = function () { return this.vertical ? 'clientHeight' : 'clientWidth'; };
    /**
     * @return {?}
     */
    AxisResolver.prototype.offsetHeightKey = function () { return this.vertical ? 'offsetHeight' : 'offsetWidth'; };
    /**
     * @return {?}
     */
    AxisResolver.prototype.scrollHeightKey = function () { return this.vertical ? 'scrollHeight' : 'scrollWidth'; };
    /**
     * @return {?}
     */
    AxisResolver.prototype.pageYOffsetKey = function () { return this.vertical ? 'pageYOffset' : 'pageXOffset'; };
    /**
     * @return {?}
     */
    AxisResolver.prototype.offsetTopKey = function () { return this.vertical ? 'offsetTop' : 'offsetLeft'; };
    /**
     * @return {?}
     */
    AxisResolver.prototype.scrollTopKey = function () { return this.vertical ? 'scrollTop' : 'scrollLeft'; };
    /**
     * @return {?}
     */
    AxisResolver.prototype.topKey = function () { return this.vertical ? 'top' : 'left'; };
    return AxisResolver;
}());
var PositionResolverFactory = (function () {
    /**
     * @param {?} axisResolver
     */
    function PositionResolverFactory(axisResolver) {
        this.axisResolver = axisResolver;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    PositionResolverFactory.prototype.create = function (options) {
        return new PositionResolver(this.axisResolver.create(!options.horizontal), options);
    };
    return PositionResolverFactory;
}());
PositionResolverFactory.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
PositionResolverFactory.ctorParameters = function () { return [
    { type: AxisResolverFactory, },
]; };
var PositionResolver = (function () {
    /**
     * @param {?} axis
     * @param {?} options
     */
    function PositionResolver(axis, options) {
        this.axis = axis;
        this.options = options;
        this.resolveContainer(this.options.windowElement);
        this.defineContainer(this.options.windowElement);
    }
    /**
     * @param {?} windowElement
     * @return {?}
     */
    PositionResolver.prototype.defineContainer = function (windowElement) {
        if (this.resolveContainer(windowElement) || !windowElement.nativeElement) {
            this.container = windowElement;
        }
        else {
            this.container = windowElement.nativeElement;
        }
        return this.container;
    };
    /**
     * @param {?} windowElement
     * @return {?}
     */
    PositionResolver.prototype.resolveContainer = function (windowElement) {
        var /** @type {?} */ isContainerWindow = Object.prototype.toString.call(windowElement).includes('Window');
        this.isContainerWindow = isContainerWindow;
        return isContainerWindow;
    };
    /**
     * @return {?}
     */
    PositionResolver.prototype.getDocumentElement = function () {
        return this.isContainerWindow
            ? this.options.windowElement.document.documentElement
            : null;
    };
    /**
     * @param {?} element
     * @return {?}
     */
    PositionResolver.prototype.calculatePoints = function (element) {
        return this.isContainerWindow
            ? this.calculatePointsForWindow(element)
            : this.calculatePointsForElement(element);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    PositionResolver.prototype.calculatePointsForWindow = function (element) {
        // container's height
        var /** @type {?} */ height = this.height(this.container);
        // scrolled until now / current y point
        var /** @type {?} */ scrolledUntilNow = height + this.pageYOffset(this.getDocumentElement());
        // total height / most bottom y point
        var /** @type {?} */ totalToScroll = this.offsetTop(element.nativeElement) + this.height(element.nativeElement);
        return { height: height, scrolledUntilNow: scrolledUntilNow, totalToScroll: totalToScroll };
    };
    /**
     * @param {?} element
     * @return {?}
     */
    PositionResolver.prototype.calculatePointsForElement = function (element) {
        var /** @type {?} */ scrollTop = this.axis.scrollTopKey();
        var /** @type {?} */ scrollHeight = this.axis.scrollHeightKey();
        var /** @type {?} */ container = this.container;
        var /** @type {?} */ height = this.height(container);
        // perhaps use this.container.offsetTop instead of 'scrollTop'
        var /** @type {?} */ scrolledUntilNow = container[scrollTop];
        var /** @type {?} */ containerTopOffset = 0;
        var /** @type {?} */ offsetTop = this.offsetTop(container);
        if (offsetTop !== void 0) {
            containerTopOffset = offsetTop;
        }
        var /** @type {?} */ totalToScroll = container[scrollHeight];
        return { height: height, scrolledUntilNow: scrolledUntilNow, totalToScroll: totalToScroll };
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    PositionResolver.prototype.height = function (elem) {
        var /** @type {?} */ offsetHeight = this.axis.offsetHeightKey();
        var /** @type {?} */ clientHeight = this.axis.clientHeightKey();
        // elem = elem.nativeElement;
        if (isNaN(elem[offsetHeight])) {
            return this.getDocumentElement()[clientHeight];
        }
        else {
            return elem[offsetHeight];
        }
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    PositionResolver.prototype.offsetTop = function (elem) {
        var /** @type {?} */ top = this.axis.topKey();
        // elem = elem.nativeElement;
        if (!elem.getBoundingClientRect) {
            return;
        }
        return elem.getBoundingClientRect()[top] + this.pageYOffset(elem);
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    PositionResolver.prototype.pageYOffset = function (elem) {
        var /** @type {?} */ pageYOffset = this.axis.pageYOffsetKey();
        var /** @type {?} */ scrollTop = this.axis.scrollTopKey();
        var /** @type {?} */ offsetTop = this.axis.offsetTopKey();
        // elem = elem.nativeElement;
        if (isNaN(window[pageYOffset])) {
            return this.getDocumentElement()[scrollTop];
        }
        else if (elem.ownerDocument) {
            return elem.ownerDocument.defaultView[pageYOffset];
        }
        else {
            return elem[offsetTop];
        }
    };
    return PositionResolver;
}());
var ScrollRegister = (function () {
    function ScrollRegister() {
    }
    /**
     * @param {?} options
     * @return {?}
     */
    ScrollRegister.prototype.attachEvent = function (options) {
        var /** @type {?} */ scroller$ = Observable.fromEvent(options.container, 'scroll')[options.throttleType](function () { return Observable.timer(options.throttleDuration); })
            .filter(options.filterBefore)
            .mergeMap(function (ev) { return Observable.of(options.mergeMap(ev)); })
            .subscribe(options.scrollHandler);
        return scroller$;
    };
    return ScrollRegister;
}());
ScrollRegister.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ScrollRegister.ctorParameters = function () { return []; };
var ScrollResolver = (function () {
    function ScrollResolver() {
        this.lastScrollPosition = 0;
    }
    /**
     * @param {?} container
     * @param {?} config
     * @param {?} scrollingDown
     * @return {?}
     */
    ScrollResolver.prototype.shouldScroll = function (container, config, scrollingDown) {
        var /** @type {?} */ distance = config.distance;
        var /** @type {?} */ remaining;
        var /** @type {?} */ containerBreakpoint;
        if (scrollingDown) {
            remaining = container.totalToScroll - container.scrolledUntilNow;
            containerBreakpoint = container.height * distance.down + 1;
        }
        else {
            remaining = container.scrolledUntilNow;
            containerBreakpoint = container.height * distance.up + 1;
        }
        var /** @type {?} */ shouldScroll = remaining <= containerBreakpoint;
        this.lastScrollPosition = container.scrolledUntilNow;
        return shouldScroll;
    };
    /**
     * @param {?} container
     * @return {?}
     */
    ScrollResolver.prototype.isScrollingDown = function (container) {
        return this.lastScrollPosition < container.scrolledUntilNow;
    };
    /**
     * @param {?} container
     * @param {?} config
     * @return {?}
     */
    ScrollResolver.prototype.getScrollStats = function (container, config) {
        var /** @type {?} */ isScrollingDown = this.isScrollingDown(container);
        var /** @type {?} */ shouldScroll = this.shouldScroll(container, config, isScrollingDown);
        return { isScrollingDown: isScrollingDown, shouldScroll: shouldScroll };
    };
    return ScrollResolver;
}());
ScrollResolver.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ScrollResolver.ctorParameters = function () { return []; };
var InfiniteScroll = (function () {
    /**
     * @param {?} element
     * @param {?} zone
     * @param {?} positionResolverFactory
     * @param {?} scrollRegister
     * @param {?} scrollerResolver
     */
    function InfiniteScroll(element, zone, positionResolverFactory, scrollRegister, scrollerResolver) {
        this.element = element;
        this.zone = zone;
        this.positionResolverFactory = positionResolverFactory;
        this.scrollRegister = scrollRegister;
        this.scrollerResolver = scrollerResolver;
        this.scrolled = new EventEmitter();
        this.scrolledUp = new EventEmitter();
        this._distanceDown = 2;
        this._distanceUp = 1.5;
        this._throttle = 300;
        this._disabled = false;
        this._container = null;
        this.scrollWindow = true;
        this._immediate = false;
        this._horizontal = false;
        this._alwaysCallback = false;
        this.throttleType = 'throttle';
    }
    Object.defineProperty(InfiniteScroll.prototype, "debounce", {
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this.throttleType = value === '' || !!value ? 'debounce' : 'throttle';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    InfiniteScroll.prototype.ngOnInit = function () {
        var _this = this;
        if (typeof window !== 'undefined') {
            var /** @type {?} */ containerElement = this.resolveContainerElement();
            var /** @type {?} */ positionResolver_1 = this.positionResolverFactory.create({
                windowElement: containerElement,
                horizontal: this._horizontal
            });
            var /** @type {?} */ options = {
                container: positionResolver_1.container,
                throttleType: this.throttleType,
                throttleDuration: this._throttle,
                filterBefore: function () { return !_this._disabled; },
                mergeMap: function () { return positionResolver_1.calculatePoints(_this.element); },
                scrollHandler: function (container) { return _this.handleOnScroll(container); }
            };
            this.disposeScroller = this.scrollRegister.attachEvent(options);
        }
    };
    /**
     * @param {?} container
     * @return {?}
     */
    InfiniteScroll.prototype.handleOnScroll = function (container) {
        var /** @type {?} */ scrollResolverConfig = {
            distance: {
                down: this._distanceDown,
                up: this._distanceUp
            }
        };
        var /** @type {?} */ scrollStats = this.scrollerResolver.getScrollStats(container, scrollResolverConfig);
        if (this.shouldTriggerEvents(scrollStats.shouldScroll)) {
            var /** @type {?} */ infiniteScrollEvent = {
                currentScrollPosition: container.scrolledUntilNow
            };
            if (scrollStats.isScrollingDown) {
                this.onScrollDown(infiniteScrollEvent);
            }
            else {
                this.onScrollUp(infiniteScrollEvent);
            }
        }
    };
    /**
     * @param {?} shouldScroll
     * @return {?}
     */
    InfiniteScroll.prototype.shouldTriggerEvents = function (shouldScroll) {
        return (this._alwaysCallback || shouldScroll) && !this._disabled;
    };
    /**
     * @return {?}
     */
    InfiniteScroll.prototype.ngOnDestroy = function () {
        if (this.disposeScroller) {
            this.disposeScroller.unsubscribe();
        }
    };
    /**
     * @param {?=} data
     * @return {?}
     */
    InfiniteScroll.prototype.onScrollDown = function (data) {
        var _this = this;
        if (data === void 0) { data = { currentScrollPosition: 0 }; }
        this.zone.run(function () { return _this.scrolled.emit(data); });
    };
    /**
     * @param {?=} data
     * @return {?}
     */
    InfiniteScroll.prototype.onScrollUp = function (data) {
        var _this = this;
        if (data === void 0) { data = { currentScrollPosition: 0 }; }
        this.zone.run(function () { return _this.scrolledUp.emit(data); });
    };
    /**
     * @return {?}
     */
    InfiniteScroll.prototype.resolveContainerElement = function () {
        if (this._container) {
            return typeof (this._container) === 'string' ? window.document.querySelector(this._container) : this._container;
        }
        else {
            return this.scrollWindow ? window : this.element;
        }
    };
    return InfiniteScroll;
}());
InfiniteScroll.decorators = [
    { type: Directive, args: [{
                selector: '[infinite-scroll]'
            },] },
];
/**
 * @nocollapse
 */
InfiniteScroll.ctorParameters = function () { return [
    { type: ElementRef, },
    { type: NgZone, },
    { type: PositionResolverFactory, },
    { type: ScrollRegister, },
    { type: ScrollResolver, },
]; };
InfiniteScroll.propDecorators = {
    'scrolled': [{ type: Output },],
    'scrolledUp': [{ type: Output },],
    '_distanceDown': [{ type: Input, args: ['infiniteScrollDistance',] },],
    '_distanceUp': [{ type: Input, args: ['infiniteScrollUpDistance',] },],
    '_throttle': [{ type: Input, args: ['infiniteScrollThrottle',] },],
    '_disabled': [{ type: Input, args: ['infiniteScrollDisabled',] },],
    '_container': [{ type: Input, args: ['infiniteScrollContainer',] },],
    'scrollWindow': [{ type: Input, args: ['scrollWindow',] },],
    '_immediate': [{ type: Input, args: ['immediateCheck',] },],
    '_horizontal': [{ type: Input, args: ['horizontal',] },],
    '_alwaysCallback': [{ type: Input, args: ['alwaysCallback',] },],
    'debounce': [{ type: Input },],
};
var InfiniteScrollModule = (function () {
    function InfiniteScrollModule() {
    }
    return InfiniteScrollModule;
}());
InfiniteScrollModule.decorators = [
    { type: NgModule, args: [{
                declarations: [InfiniteScroll],
                exports: [InfiniteScroll],
                imports: [],
                providers: [
                    AxisResolverFactory,
                    PositionResolverFactory,
                    ScrollRegister,
                    ScrollResolver
                ]
            },] },
];
/**
 * @nocollapse
 */
InfiniteScrollModule.ctorParameters = function () { return []; };
/**
 * Angular library starter.
 * Build an Angular library compatible with AoT compilation & Tree shaking.
 * Written by Roberto Simonetti.
 * MIT license.
 * https://github.com/robisim74/angular-library-starter
 */
/**
 * Entry point for all public APIs of the package.
 */
/**
 * Generated bundle index. Do not edit.
 */
export { InfiniteScrollModule, InfiniteScroll as ɵa, AxisResolverFactory as ɵc, PositionResolverFactory as ɵb, ScrollRegister as ɵd, ScrollResolver as ɵe };
//# sourceMappingURL=ngx-infinite-scroll.es5.js.map
