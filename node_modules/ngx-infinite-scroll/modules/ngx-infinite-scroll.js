import { Directive, ElementRef, EventEmitter, Injectable, Input, NgModule, NgZone, Output } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/fromEvent';
import 'rxjs/add/observable/timer';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/debounce';
import 'rxjs/add/operator/throttle';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/mergeMap';

class AxisResolverFactory {
    constructor() { }
    /**
     * @param {?=} vertical
     * @return {?}
     */
    create(vertical = true) {
        return new AxisResolver(vertical);
    }
}
AxisResolverFactory.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
AxisResolverFactory.ctorParameters = () => [];
class AxisResolver {
    /**
     * @param {?=} vertical
     */
    constructor(vertical = true) {
        this.vertical = vertical;
    }
    /**
     * @return {?}
     */
    clientHeightKey() { return this.vertical ? 'clientHeight' : 'clientWidth'; }
    /**
     * @return {?}
     */
    offsetHeightKey() { return this.vertical ? 'offsetHeight' : 'offsetWidth'; }
    /**
     * @return {?}
     */
    scrollHeightKey() { return this.vertical ? 'scrollHeight' : 'scrollWidth'; }
    /**
     * @return {?}
     */
    pageYOffsetKey() { return this.vertical ? 'pageYOffset' : 'pageXOffset'; }
    /**
     * @return {?}
     */
    offsetTopKey() { return this.vertical ? 'offsetTop' : 'offsetLeft'; }
    /**
     * @return {?}
     */
    scrollTopKey() { return this.vertical ? 'scrollTop' : 'scrollLeft'; }
    /**
     * @return {?}
     */
    topKey() { return this.vertical ? 'top' : 'left'; }
}

class PositionResolverFactory {
    /**
     * @param {?} axisResolver
     */
    constructor(axisResolver) {
        this.axisResolver = axisResolver;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    create(options) {
        return new PositionResolver(this.axisResolver.create(!options.horizontal), options);
    }
}
PositionResolverFactory.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
PositionResolverFactory.ctorParameters = () => [
    { type: AxisResolverFactory, },
];
class PositionResolver {
    /**
     * @param {?} axis
     * @param {?} options
     */
    constructor(axis, options) {
        this.axis = axis;
        this.options = options;
        this.resolveContainer(this.options.windowElement);
        this.defineContainer(this.options.windowElement);
    }
    /**
     * @param {?} windowElement
     * @return {?}
     */
    defineContainer(windowElement) {
        if (this.resolveContainer(windowElement) || !windowElement.nativeElement) {
            this.container = windowElement;
        }
        else {
            this.container = windowElement.nativeElement;
        }
        return this.container;
    }
    /**
     * @param {?} windowElement
     * @return {?}
     */
    resolveContainer(windowElement) {
        const /** @type {?} */ isContainerWindow = Object.prototype.toString.call(windowElement).includes('Window');
        this.isContainerWindow = isContainerWindow;
        return isContainerWindow;
    }
    /**
     * @return {?}
     */
    getDocumentElement() {
        return this.isContainerWindow
            ? this.options.windowElement.document.documentElement
            : null;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    calculatePoints(element) {
        return this.isContainerWindow
            ? this.calculatePointsForWindow(element)
            : this.calculatePointsForElement(element);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    calculatePointsForWindow(element) {
        // container's height
        const /** @type {?} */ height = this.height(this.container);
        // scrolled until now / current y point
        const /** @type {?} */ scrolledUntilNow = height + this.pageYOffset(this.getDocumentElement());
        // total height / most bottom y point
        const /** @type {?} */ totalToScroll = this.offsetTop(element.nativeElement) + this.height(element.nativeElement);
        return { height, scrolledUntilNow, totalToScroll };
    }
    /**
     * @param {?} element
     * @return {?}
     */
    calculatePointsForElement(element) {
        let /** @type {?} */ scrollTop = this.axis.scrollTopKey();
        let /** @type {?} */ scrollHeight = this.axis.scrollHeightKey();
        const /** @type {?} */ container = this.container;
        const /** @type {?} */ height = this.height(container);
        // perhaps use this.container.offsetTop instead of 'scrollTop'
        const /** @type {?} */ scrolledUntilNow = container[scrollTop];
        let /** @type {?} */ containerTopOffset = 0;
        const /** @type {?} */ offsetTop = this.offsetTop(container);
        if (offsetTop !== void 0) {
            containerTopOffset = offsetTop;
        }
        const /** @type {?} */ totalToScroll = container[scrollHeight];
        return { height, scrolledUntilNow, totalToScroll };
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    height(elem) {
        let /** @type {?} */ offsetHeight = this.axis.offsetHeightKey();
        let /** @type {?} */ clientHeight = this.axis.clientHeightKey();
        // elem = elem.nativeElement;
        if (isNaN(elem[offsetHeight])) {
            return this.getDocumentElement()[clientHeight];
        }
        else {
            return elem[offsetHeight];
        }
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    offsetTop(elem) {
        let /** @type {?} */ top = this.axis.topKey();
        // elem = elem.nativeElement;
        if (!elem.getBoundingClientRect) {
            return;
        }
        return elem.getBoundingClientRect()[top] + this.pageYOffset(elem);
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    pageYOffset(elem) {
        let /** @type {?} */ pageYOffset = this.axis.pageYOffsetKey();
        let /** @type {?} */ scrollTop = this.axis.scrollTopKey();
        let /** @type {?} */ offsetTop = this.axis.offsetTopKey();
        // elem = elem.nativeElement;
        if (isNaN(window[pageYOffset])) {
            return this.getDocumentElement()[scrollTop];
        }
        else if (elem.ownerDocument) {
            return elem.ownerDocument.defaultView[pageYOffset];
        }
        else {
            return elem[offsetTop];
        }
    }
}

class ScrollRegister {
    /**
     * @param {?} options
     * @return {?}
     */
    attachEvent(options) {
        const /** @type {?} */ scroller$ = Observable.fromEvent(options.container, 'scroll')[options.throttleType](() => Observable.timer(options.throttleDuration))
            .filter(options.filterBefore)
            .mergeMap((ev) => Observable.of(options.mergeMap(ev)))
            .subscribe(options.scrollHandler);
        return scroller$;
    }
}
ScrollRegister.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ScrollRegister.ctorParameters = () => [];

class ScrollResolver {
    constructor() {
        this.lastScrollPosition = 0;
    }
    /**
     * @param {?} container
     * @param {?} config
     * @param {?} scrollingDown
     * @return {?}
     */
    shouldScroll(container, config, scrollingDown) {
        const /** @type {?} */ distance = config.distance;
        let /** @type {?} */ remaining;
        let /** @type {?} */ containerBreakpoint;
        if (scrollingDown) {
            remaining = container.totalToScroll - container.scrolledUntilNow;
            containerBreakpoint = container.height * distance.down + 1;
        }
        else {
            remaining = container.scrolledUntilNow;
            containerBreakpoint = container.height * distance.up + 1;
        }
        const /** @type {?} */ shouldScroll = remaining <= containerBreakpoint;
        this.lastScrollPosition = container.scrolledUntilNow;
        return shouldScroll;
    }
    /**
     * @param {?} container
     * @return {?}
     */
    isScrollingDown(container) {
        return this.lastScrollPosition < container.scrolledUntilNow;
    }
    /**
     * @param {?} container
     * @param {?} config
     * @return {?}
     */
    getScrollStats(container, config) {
        const /** @type {?} */ isScrollingDown = this.isScrollingDown(container);
        const /** @type {?} */ shouldScroll = this.shouldScroll(container, config, isScrollingDown);
        return { isScrollingDown, shouldScroll };
    }
}
ScrollResolver.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ScrollResolver.ctorParameters = () => [];

class InfiniteScroll {
    /**
     * @param {?} element
     * @param {?} zone
     * @param {?} positionResolverFactory
     * @param {?} scrollRegister
     * @param {?} scrollerResolver
     */
    constructor(element, zone, positionResolverFactory, scrollRegister, scrollerResolver) {
        this.element = element;
        this.zone = zone;
        this.positionResolverFactory = positionResolverFactory;
        this.scrollRegister = scrollRegister;
        this.scrollerResolver = scrollerResolver;
        this.scrolled = new EventEmitter();
        this.scrolledUp = new EventEmitter();
        this._distanceDown = 2;
        this._distanceUp = 1.5;
        this._throttle = 300;
        this._disabled = false;
        this._container = null;
        this.scrollWindow = true;
        this._immediate = false;
        this._horizontal = false;
        this._alwaysCallback = false;
        this.throttleType = 'throttle';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set debounce(value) {
        this.throttleType = value === '' || !!value ? 'debounce' : 'throttle';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (typeof window !== 'undefined') {
            const /** @type {?} */ containerElement = this.resolveContainerElement();
            const /** @type {?} */ positionResolver = this.positionResolverFactory.create({
                windowElement: containerElement,
                horizontal: this._horizontal
            });
            const /** @type {?} */ options = {
                container: positionResolver.container,
                throttleType: this.throttleType,
                throttleDuration: this._throttle,
                filterBefore: () => !this._disabled,
                mergeMap: () => positionResolver.calculatePoints(this.element),
                scrollHandler: (container) => this.handleOnScroll(container)
            };
            this.disposeScroller = this.scrollRegister.attachEvent(options);
        }
    }
    /**
     * @param {?} container
     * @return {?}
     */
    handleOnScroll(container) {
        const /** @type {?} */ scrollResolverConfig = {
            distance: {
                down: this._distanceDown,
                up: this._distanceUp
            }
        };
        const /** @type {?} */ scrollStats = this.scrollerResolver.getScrollStats(container, scrollResolverConfig);
        if (this.shouldTriggerEvents(scrollStats.shouldScroll)) {
            const /** @type {?} */ infiniteScrollEvent = {
                currentScrollPosition: container.scrolledUntilNow
            };
            if (scrollStats.isScrollingDown) {
                this.onScrollDown(infiniteScrollEvent);
            }
            else {
                this.onScrollUp(infiniteScrollEvent);
            }
        }
    }
    /**
     * @param {?} shouldScroll
     * @return {?}
     */
    shouldTriggerEvents(shouldScroll) {
        return (this._alwaysCallback || shouldScroll) && !this._disabled;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.disposeScroller) {
            this.disposeScroller.unsubscribe();
        }
    }
    /**
     * @param {?=} data
     * @return {?}
     */
    onScrollDown(data = { currentScrollPosition: 0 }) {
        this.zone.run(() => this.scrolled.emit(data));
    }
    /**
     * @param {?=} data
     * @return {?}
     */
    onScrollUp(data = { currentScrollPosition: 0 }) {
        this.zone.run(() => this.scrolledUp.emit(data));
    }
    /**
     * @return {?}
     */
    resolveContainerElement() {
        if (this._container) {
            return typeof (this._container) === 'string' ? window.document.querySelector(this._container) : this._container;
        }
        else {
            return this.scrollWindow ? window : this.element;
        }
    }
}
InfiniteScroll.decorators = [
    { type: Directive, args: [{
                selector: '[infinite-scroll]'
            },] },
];
/**
 * @nocollapse
 */
InfiniteScroll.ctorParameters = () => [
    { type: ElementRef, },
    { type: NgZone, },
    { type: PositionResolverFactory, },
    { type: ScrollRegister, },
    { type: ScrollResolver, },
];
InfiniteScroll.propDecorators = {
    'scrolled': [{ type: Output },],
    'scrolledUp': [{ type: Output },],
    '_distanceDown': [{ type: Input, args: ['infiniteScrollDistance',] },],
    '_distanceUp': [{ type: Input, args: ['infiniteScrollUpDistance',] },],
    '_throttle': [{ type: Input, args: ['infiniteScrollThrottle',] },],
    '_disabled': [{ type: Input, args: ['infiniteScrollDisabled',] },],
    '_container': [{ type: Input, args: ['infiniteScrollContainer',] },],
    'scrollWindow': [{ type: Input, args: ['scrollWindow',] },],
    '_immediate': [{ type: Input, args: ['immediateCheck',] },],
    '_horizontal': [{ type: Input, args: ['horizontal',] },],
    '_alwaysCallback': [{ type: Input, args: ['alwaysCallback',] },],
    'debounce': [{ type: Input },],
};

class InfiniteScrollModule {
}
InfiniteScrollModule.decorators = [
    { type: NgModule, args: [{
                declarations: [InfiniteScroll],
                exports: [InfiniteScroll],
                imports: [],
                providers: [
                    AxisResolverFactory,
                    PositionResolverFactory,
                    ScrollRegister,
                    ScrollResolver
                ]
            },] },
];
/**
 * @nocollapse
 */
InfiniteScrollModule.ctorParameters = () => [];

/**
 * Angular library starter.
 * Build an Angular library compatible with AoT compilation & Tree shaking.
 * Written by Roberto Simonetti.
 * MIT license.
 * https://github.com/robisim74/angular-library-starter
 */
/**
 * Entry point for all public APIs of the package.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { InfiniteScrollModule, InfiniteScroll as ɵa, AxisResolverFactory as ɵc, PositionResolverFactory as ɵb, ScrollRegister as ɵd, ScrollResolver as ɵe };
//# sourceMappingURL=ngx-infinite-scroll.js.map
