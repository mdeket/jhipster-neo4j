{"version":3,"file":"ngx-infinite-scroll.umd.min.js","sources":["../../src/services/axis-resolver.ts","../../src/services/position-resolver.ts","../../src/services/scroll-register.ts","../../src/services/scroll-resolver.ts","../../src/modules/infinite-scroll.ts","../../src/modules/ngx-infinite-scroll.module.ts"],"sourcesContent":["import { Injectable, Inject } from '@angular/core';\nexport class AxisResolverFactory {\nconstructor() { }\n/**\n * @param {?=} vertical\n * @return {?}\n */\ncreate(vertical: boolean = true) {\n    return new AxisResolver(vertical);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction AxisResolverFactory_tsickle_Closure_declarations() {\n/** @type {?} */\nAxisResolverFactory.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nAxisResolverFactory.ctorParameters;\n}\n\nexport class AxisResolver {\n/**\n * @param {?=} vertical\n */\nconstructor(private vertical: boolean = true) {\n  }\n/**\n * @return {?}\n */\nclientHeightKey() { return this.vertical ? 'clientHeight' : 'clientWidth'; }\n/**\n * @return {?}\n */\noffsetHeightKey() { return this.vertical ? 'offsetHeight' : 'offsetWidth'; }\n/**\n * @return {?}\n */\nscrollHeightKey() { return this.vertical ? 'scrollHeight' : 'scrollWidth'; }\n/**\n * @return {?}\n */\npageYOffsetKey() { return this.vertical ? 'pageYOffset' : 'pageXOffset'; }\n/**\n * @return {?}\n */\noffsetTopKey() { return this.vertical ? 'offsetTop' : 'offsetLeft'; }\n/**\n * @return {?}\n */\nscrollTopKey() { return this.vertical ? 'scrollTop' : 'scrollLeft'; }\n/**\n * @return {?}\n */\ntopKey() { return this.vertical ? 'top' : 'left'; }\n}\n\nfunction AxisResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nAxisResolver.prototype.vertical;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Injectable, ElementRef } from '@angular/core';\nimport { AxisResolver, AxisResolverFactory } from './axis-resolver';\nimport { ContainerRef, PositionElements, PositionStats } from '../models';\nexport class PositionResolverFactory {\n/**\n * @param {?} axisResolver\n */\nconstructor(private axisResolver: AxisResolverFactory) {\n  }\n/**\n * @param {?} options\n * @return {?}\n */\ncreate (options: PositionElements) {\n    return new PositionResolver(this.axisResolver.create(!options.horizontal), options);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: AxisResolverFactory, },\n];\n}\n\nfunction PositionResolverFactory_tsickle_Closure_declarations() {\n/** @type {?} */\nPositionResolverFactory.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nPositionResolverFactory.ctorParameters;\n/** @type {?} */\nPositionResolverFactory.prototype.axisResolver;\n}\n\nexport class PositionResolver {\nprivate documentElement: ContainerRef;\nprivate isContainerWindow: boolean;\npublic container: ContainerRef;\n/**\n * @param {?} axis\n * @param {?} options\n */\nconstructor (private axis: AxisResolver,\nprivate options: PositionElements) {\n    this.resolveContainer(this.options.windowElement);\n    this.defineContainer(this.options.windowElement);\n  }\n/**\n * @param {?} windowElement\n * @return {?}\n */\ndefineContainer(windowElement: ContainerRef) {\n    if (this.resolveContainer(windowElement) || !windowElement.nativeElement) {\n      this.container = windowElement;\n    } else {\n      this.container = windowElement.nativeElement;\n    }\n    return this.container;\n  }\n/**\n * @param {?} windowElement\n * @return {?}\n */\nresolveContainer(windowElement: ContainerRef): boolean {\n    const /** @type {?} */ isContainerWindow = Object.prototype.toString.call(windowElement).includes('Window');\n    this.isContainerWindow = isContainerWindow;\n    return isContainerWindow;\n  }\n/**\n * @return {?}\n */\ngetDocumentElement() {\n    return this.isContainerWindow\n      ? this.options.windowElement.document.documentElement\n      : null;\n  }\n/**\n * @param {?} element\n * @return {?}\n */\ncalculatePoints (element: ElementRef) {\n    return this.isContainerWindow\n      ? this.calculatePointsForWindow(element)\n      : this.calculatePointsForElement(element);\n  }\n/**\n * @param {?} element\n * @return {?}\n */\ncalculatePointsForWindow (element: ElementRef): PositionStats {\n    // container's height\n    const /** @type {?} */ height = this.height(this.container);\n    // scrolled until now / current y point\n    const /** @type {?} */ scrolledUntilNow = height + this.pageYOffset(this.getDocumentElement());\n    // total height / most bottom y point\n    const /** @type {?} */ totalToScroll = this.offsetTop(element.nativeElement) + this.height(element.nativeElement);\n    return { height, scrolledUntilNow, totalToScroll };\n  }\n/**\n * @param {?} element\n * @return {?}\n */\ncalculatePointsForElement (element: ElementRef) {\n    let /** @type {?} */ scrollTop    = this.axis.scrollTopKey();\n    let /** @type {?} */ scrollHeight = this.axis.scrollHeightKey();\n    const /** @type {?} */ container = this.container;\n\n    const /** @type {?} */ height = this.height(container);\n    // perhaps use this.container.offsetTop instead of 'scrollTop'\n    const /** @type {?} */ scrolledUntilNow = container[scrollTop];\n    let /** @type {?} */ containerTopOffset = 0;\n    const /** @type {?} */ offsetTop = this.offsetTop(container);\n    if (offsetTop !== void 0) {\n      containerTopOffset = offsetTop;\n    }\n    const /** @type {?} */ totalToScroll = container[scrollHeight];\n    return { height, scrolledUntilNow, totalToScroll };\n  }\n/**\n * @param {?} elem\n * @return {?}\n */\nprivate height (elem: any) {\n    let /** @type {?} */ offsetHeight = this.axis.offsetHeightKey();\n    let /** @type {?} */ clientHeight = this.axis.clientHeightKey();\n\n    // elem = elem.nativeElement;\n    if (isNaN(elem[offsetHeight])) {\n      return this.getDocumentElement()[clientHeight];\n    } else {\n      return elem[offsetHeight];\n    }\n  }\n/**\n * @param {?} elem\n * @return {?}\n */\nprivate offsetTop (elem: any) {\n    let /** @type {?} */ top = this.axis.topKey();\n\n    // elem = elem.nativeElement;\n    if (!elem.getBoundingClientRect) { // || elem.css('none')) {\n      return;\n    }\n    return elem.getBoundingClientRect()[top] + this.pageYOffset(elem);\n  }\n/**\n * @param {?} elem\n * @return {?}\n */\npageYOffset (elem: any) {\n    let /** @type {?} */ pageYOffset = this.axis.pageYOffsetKey();\n    let /** @type {?} */ scrollTop   = this.axis.scrollTopKey();\n    let /** @type {?} */ offsetTop   = this.axis.offsetTopKey();\n\n    // elem = elem.nativeElement;\n    if (isNaN(window[pageYOffset])) {\n      return this.getDocumentElement()[scrollTop];\n    } else if (elem.ownerDocument) {\n      return elem.ownerDocument.defaultView[pageYOffset];\n    } else {\n      return elem[offsetTop];\n    }\n  }\n}\n\nfunction PositionResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nPositionResolver.prototype.documentElement;\n/** @type {?} */\nPositionResolver.prototype.isContainerWindow;\n/** @type {?} */\nPositionResolver.prototype.container;\n/** @type {?} */\nPositionResolver.prototype.axis;\n/** @type {?} */\nPositionResolver.prototype.options;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { ContainerRef } from '../models';\nimport { Injectable, ElementRef } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\nimport { Subscription } from 'rxjs/Subscription';\nimport'rxjs/add/observable/fromEvent';\nimport'rxjs/add/observable/timer';\nimport'rxjs/add/observable/of';\nimport'rxjs/add/operator/debounce';\nimport'rxjs/add/operator/throttle';\nimport'rxjs/add/operator/filter';\nimport'rxjs/add/operator/mergeMap';\n\n\nexport interface ScrollRegisterConfig {\n  container: ContainerRef;\n  throttleType: string;\n  throttleDuration: number;\n  filterBefore: Function;\n  mergeMap: Function;\n  scrollHandler: Function;\n}\nexport class ScrollRegister {\n/**\n * @param {?} options\n * @return {?}\n */\nattachEvent (options: ScrollRegisterConfig): Subscription {\n    const /** @type {?} */ scroller$: Subscription = Observable.fromEvent(options.container, 'scroll')\n      [options.throttleType](() => Observable.timer(options.throttleDuration))\n      .filter(options.filterBefore)\n      .mergeMap((ev: any) => Observable.of(options.mergeMap(ev)))\n      .subscribe(options.scrollHandler);\n    return scroller$;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ScrollRegister_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollRegister.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollRegister.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { PositionStats, ScrollerConfig } from '../models';\nimport { Injectable } from '@angular/core';\nexport class ScrollResolver {\npublic lastScrollPosition: number = 0;\n/**\n * @param {?} container\n * @param {?} config\n * @param {?} scrollingDown\n * @return {?}\n */\nshouldScroll (container: PositionStats, config: ScrollerConfig, scrollingDown: boolean) {\n    const /** @type {?} */ distance = config.distance;\n    let /** @type {?} */ remaining: number;\n    let /** @type {?} */ containerBreakpoint: number;\n    if (scrollingDown) {\n      remaining = container.totalToScroll - container.scrolledUntilNow;\n      containerBreakpoint = container.height * distance.down + 1;\n    } else {\n      remaining = container.scrolledUntilNow;\n      containerBreakpoint = container.height * distance.up + 1;\n    }\n    const /** @type {?} */ shouldScroll: boolean = remaining <= containerBreakpoint;\n    this.lastScrollPosition = container.scrolledUntilNow;\n    return shouldScroll;\n  }\n/**\n * @param {?} container\n * @return {?}\n */\nisScrollingDown (container: PositionStats) {\n    return this.lastScrollPosition < container.scrolledUntilNow;\n  }\n/**\n * @param {?} container\n * @param {?} config\n * @return {?}\n */\ngetScrollStats (container: PositionStats, config: ScrollerConfig) {\n    const /** @type {?} */ isScrollingDown = this.isScrollingDown(container);\n    const /** @type {?} */ shouldScroll = this.shouldScroll(container, config, isScrollingDown);\n    return { isScrollingDown, shouldScroll };\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ScrollResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollResolver.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollResolver.ctorParameters;\n/** @type {?} */\nScrollResolver.prototype.lastScrollPosition;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { InfiniteScrollEvent, ScrollStats, PositionStats } from '../models';\nimport {\n  Directive, ElementRef, Input, Output,\n  EventEmitter, OnDestroy, OnInit,\n  SimpleChanges, NgZone\n} from '@angular/core';\nimport { PositionResolverFactory } from '../services/position-resolver';\nimport { ScrollRegister, ScrollRegisterConfig } from '../services/scroll-register';\nimport { ScrollResolver } from '../services/scroll-resolver';\nimport { Subscription } from 'rxjs/Rx';\nexport class InfiniteScroll implements OnDestroy, OnInit {\n   scrolled = new EventEmitter<InfiniteScrollEvent>();\n   scrolledUp = new EventEmitter<InfiniteScrollEvent>();\n\n   _distanceDown: number = 2;\n   _distanceUp: number = 1.5;\n   _throttle: number = 300;\n   _disabled: boolean = false;\n   _container: any = null;\n   scrollWindow: boolean = true;\n   _immediate: boolean = false;\n   _horizontal: boolean = false;\n   _alwaysCallback: boolean = false;\n/**\n * @param {?} value\n * @return {?}\n */\nset debounce(value: string | boolean) {\n    this.throttleType = value === '' || !!value ? 'debounce' : 'throttle';\n  }\nprivate throttleType: string = 'throttle';\nprivate disposeScroller: Subscription;\n/**\n * @param {?} element\n * @param {?} zone\n * @param {?} positionResolverFactory\n * @param {?} scrollRegister\n * @param {?} scrollerResolver\n */\nconstructor(\nprivate element: ElementRef,\nprivate zone: NgZone,\nprivate positionResolverFactory: PositionResolverFactory,\nprivate scrollRegister: ScrollRegister,\nprivate scrollerResolver: ScrollResolver\n  ) {}\n/**\n * @return {?}\n */\nngOnInit() {\n    if (typeof window !== 'undefined') {\n      const /** @type {?} */ containerElement = this.resolveContainerElement();\n      const /** @type {?} */ positionResolver = this.positionResolverFactory.create({\n        windowElement: containerElement,\n        horizontal: this._horizontal\n      });\n      const /** @type {?} */ options: ScrollRegisterConfig = {\n        container: positionResolver.container,\n        throttleType: this.throttleType,\n        throttleDuration: this._throttle,\n        filterBefore: () => !this._disabled,\n        mergeMap: () => positionResolver.calculatePoints(this.element),\n        scrollHandler: (container: PositionStats) => this.handleOnScroll(container)\n      };\n      this.disposeScroller = this.scrollRegister.attachEvent(options);\n    }\n  }\n/**\n * @param {?} container\n * @return {?}\n */\nhandleOnScroll(container: PositionStats) {\n    const /** @type {?} */ scrollResolverConfig = {\n      distance: {\n        down: this._distanceDown,\n        up: this._distanceUp\n      }\n    };\n    const /** @type {?} */ scrollStats: ScrollStats = this.scrollerResolver.getScrollStats(container, scrollResolverConfig);\n    if (this.shouldTriggerEvents(scrollStats.shouldScroll)) {\n      const /** @type {?} */ infiniteScrollEvent: InfiniteScrollEvent = {\n        currentScrollPosition: container.scrolledUntilNow\n      };\n      if (scrollStats.isScrollingDown) {\n        this.onScrollDown(infiniteScrollEvent);\n      } else {\n        this.onScrollUp(infiniteScrollEvent);\n      }\n    }\n  }\n/**\n * @param {?} shouldScroll\n * @return {?}\n */\nshouldTriggerEvents(shouldScroll: boolean) {\n    return (this._alwaysCallback || shouldScroll) && !this._disabled;\n  }\n/**\n * @return {?}\n */\nngOnDestroy () {\n    if (this.disposeScroller) {\n      this.disposeScroller.unsubscribe();\n    }\n  }\n/**\n * @param {?=} data\n * @return {?}\n */\nonScrollDown(data: InfiniteScrollEvent = { currentScrollPosition: 0 }) {\n    this.zone.run(() => this.scrolled.emit(data));\n  }\n/**\n * @param {?=} data\n * @return {?}\n */\nonScrollUp(data: InfiniteScrollEvent = { currentScrollPosition: 0 }) {\n    this.zone.run(() => this.scrolledUp.emit(data));\n  }\n/**\n * @return {?}\n */\nprivate resolveContainerElement(): any {\n    if (this._container) {\n      return typeof(this._container) === 'string' ?  window.document.querySelector(this._container) : this._container;\n    } else {\n      return this.scrollWindow ? window : this.element;\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: '[infinite-scroll]'\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: NgZone, },\n{type: PositionResolverFactory, },\n{type: ScrollRegister, },\n{type: ScrollResolver, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'scrolled': [{ type: Output },],\n'scrolledUp': [{ type: Output },],\n'_distanceDown': [{ type: Input, args: ['infiniteScrollDistance', ] },],\n'_distanceUp': [{ type: Input, args: ['infiniteScrollUpDistance', ] },],\n'_throttle': [{ type: Input, args: ['infiniteScrollThrottle', ] },],\n'_disabled': [{ type: Input, args: ['infiniteScrollDisabled', ] },],\n'_container': [{ type: Input, args: ['infiniteScrollContainer', ] },],\n'scrollWindow': [{ type: Input, args: ['scrollWindow', ] },],\n'_immediate': [{ type: Input, args: ['immediateCheck', ] },],\n'_horizontal': [{ type: Input, args: ['horizontal', ] },],\n'_alwaysCallback': [{ type: Input, args: ['alwaysCallback', ] },],\n'debounce': [{ type: Input },],\n};\n}\n\nfunction InfiniteScroll_tsickle_Closure_declarations() {\n/** @type {?} */\nInfiniteScroll.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nInfiniteScroll.ctorParameters;\n/** @type {?} */\nInfiniteScroll.propDecorators;\n/** @type {?} */\nInfiniteScroll.prototype.scrolled;\n/** @type {?} */\nInfiniteScroll.prototype.scrolledUp;\n/** @type {?} */\nInfiniteScroll.prototype._distanceDown;\n/** @type {?} */\nInfiniteScroll.prototype._distanceUp;\n/** @type {?} */\nInfiniteScroll.prototype._throttle;\n/** @type {?} */\nInfiniteScroll.prototype._disabled;\n/** @type {?} */\nInfiniteScroll.prototype._container;\n/** @type {?} */\nInfiniteScroll.prototype.scrollWindow;\n/** @type {?} */\nInfiniteScroll.prototype._immediate;\n/** @type {?} */\nInfiniteScroll.prototype._horizontal;\n/** @type {?} */\nInfiniteScroll.prototype._alwaysCallback;\n/** @type {?} */\nInfiniteScroll.prototype.throttleType;\n/** @type {?} */\nInfiniteScroll.prototype.disposeScroller;\n/** @type {?} */\nInfiniteScroll.prototype.element;\n/** @type {?} */\nInfiniteScroll.prototype.zone;\n/** @type {?} */\nInfiniteScroll.prototype.positionResolverFactory;\n/** @type {?} */\nInfiniteScroll.prototype.scrollRegister;\n/** @type {?} */\nInfiniteScroll.prototype.scrollerResolver;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule } from '@angular/core';\n\nimport { InfiniteScroll } from './infinite-scroll';\nimport { AxisResolverFactory } from '../services/axis-resolver';\nimport { PositionResolverFactory } from '../services/position-resolver';\nimport { ScrollRegister } from '../services/scroll-register';\nimport { ScrollResolver } from '../services/scroll-resolver';\nexport class InfiniteScrollModule { static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  declarations: [InfiniteScroll],\n  exports: [InfiniteScroll],\n  imports: [],\n  providers: [\n    AxisResolverFactory,\n    PositionResolverFactory,\n    ScrollRegister,\n    ScrollResolver\n  ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction InfiniteScrollModule_tsickle_Closure_declarations() {\n/** @type {?} */\nInfiniteScrollModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nInfiniteScrollModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["AxisResolverFactory","prototype","create","vertical","AxisResolver","decorators","type","Injectable","ctorParameters","this","clientHeightKey","offsetHeightKey","scrollHeightKey","pageYOffsetKey","offsetTopKey","scrollTopKey","topKey","PositionResolverFactory","axisResolver","options","PositionResolver","horizontal","axis","resolveContainer","windowElement","defineContainer","nativeElement","container","isContainerWindow","Object","toString","call","includes","getDocumentElement","document","documentElement","calculatePoints","element","calculatePointsForWindow","calculatePointsForElement","height","scrolledUntilNow","pageYOffset","totalToScroll","offsetTop","scrollTop","scrollHeight","elem","offsetHeight","clientHeight","isNaN","top","getBoundingClientRect","window","ownerDocument","defaultView","ScrollRegister","attachEvent","Observable","fromEvent","throttleType","timer","throttleDuration","filter","filterBefore","mergeMap","ev","of","subscribe","scrollHandler","ScrollResolver","lastScrollPosition","shouldScroll","config","scrollingDown","remaining","containerBreakpoint","distance","down","up","isScrollingDown","getScrollStats","InfiniteScroll","zone","positionResolverFactory","scrollRegister","scrollerResolver","scrolled","EventEmitter","scrolledUp","_distanceDown","_distanceUp","_throttle","_disabled","_container","scrollWindow","_immediate","_horizontal","_alwaysCallback","defineProperty","set","value","ngOnInit","_this","containerElement","resolveContainerElement","positionResolver_1","handleOnScroll","disposeScroller","scrollResolverConfig","scrollStats","shouldTriggerEvents","infiniteScrollEvent","currentScrollPosition","onScrollDown","onScrollUp","ngOnDestroy","unsubscribe","data","run","emit","querySelector","Directive","args","selector","ElementRef","NgZone","propDecorators","Output","Input","debounce","InfiniteScrollModule","NgModule","declarations","exports","imports","providers"],"mappings":"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"}